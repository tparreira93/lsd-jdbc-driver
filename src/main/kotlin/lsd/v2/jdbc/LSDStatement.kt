package lsd.v2.jdbc

import lsd.v2.api.*
import lsd.v2.future.Future
import lsd.v2.future.FutureUtils
import java.sql.*

open class LSDStatement(private val lsdConnection: LSDConnection, private val backingStatement: PreparedStatement) : FutureStatement {
    private var future: Future<*>? = null
    private var executed: Boolean = false
    private var futureResultSet: FutureResultSet? = null

    override fun toString(): String {
        return backingStatement.toString()
    }

    override fun resolve(): Any {
        return future!!.resolve()!!
    }

    override fun dispose() {
        resultSet?.close()
        future = null
        executed = false

        clearBatch()
    }

    override fun executeFutureQuery(sql: String): FutureResultSet {
        val futureQuery = FutureUtils.newCachedFuture { backingStatement.executeQuery(sql) }
        future = futureQuery

        lsdConnection.addFutureStatement(this)
        futureResultSet = LSDResultSet(futureQuery)

        return futureResultSet!!
    }

    override fun executeFutureBatch(): FutureResultConsumer<IntArray> {
        val futureBatch = FutureUtils.newCachedFuture {  backingStatement.executeBatch() }
        future = futureBatch

        lsdConnection.addFutureStatement(this)

        return FutureResultConsumer(futureBatch)
    }

    override fun executeFutureUpdate(sql: String): FutureResultConsumer<Int> {
        val futureUpdate = FutureUtils.newCachedFuture { backingStatement.executeUpdate(sql) }
        future = futureUpdate

        lsdConnection.addFutureStatement(this)

        return FutureResultConsumer(futureUpdate)
    }

    override fun addFutureBatch(sql: String) {
        backingStatement.addBatch(sql)
    }


    override fun executeBatch(): IntArray {
        throw UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun addBatch(sql: String?) {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun clearBatch() {
        backingStatement.clearBatch()
    }

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        if (iface!!.isAssignableFrom(javaClass)) {
            return iface.cast(this)
        }
        throw SQLException("Cannot unwrap to " + iface.name)
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface!!.isAssignableFrom(javaClass)
    }

    override fun close() {
        backingStatement.close()
    }

    override fun executeQuery(sql: String?): ResultSet {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun executeUpdate(sql: String?): Int {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun getMaxFieldSize(): Int {
        return backingStatement.maxFieldSize
    }

    override fun setMaxFieldSize(max: Int) {
        backingStatement.maxFieldSize = max
    }

    override fun getMaxRows(): Int {
        return backingStatement.maxRows
    }

    override fun setMaxRows(max: Int) {
        backingStatement.maxRows = maxRows
    }

    override fun setEscapeProcessing(enable: Boolean) {
        backingStatement.setEscapeProcessing(enable)
    }

    override fun getQueryTimeout(): Int {
        return backingStatement.queryTimeout
    }

    override fun setQueryTimeout(seconds: Int) {
        backingStatement.queryTimeout = seconds
    }

    override fun cancel() {
        backingStatement.cancel()
    }

    override fun getWarnings(): SQLWarning {
        return backingStatement.warnings
    }

    override fun clearWarnings() {
        backingStatement.clearWarnings()
    }

    override fun setCursorName(name: String?) {
        backingStatement.setCursorName(name)
    }

    override fun execute(sql: String?): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun execute(sql: String?, columnNames: Array<out String>?): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun getResultSet(): ResultSet? {
        return backingStatement.resultSet
    }

    override fun getUpdateCount(): Int {
        return backingStatement.updateCount
    }

    override fun getMoreResults(): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun getMoreResults(current: Int): Boolean {
        throw java.lang.UnsupportedOperationException("Operation not supported in FutureStatements")
    }

    override fun setFetchDirection(direction: Int) {
        backingStatement.fetchDirection = direction
    }

    override fun getFetchDirection(): Int {
        return backingStatement.fetchDirection
    }

    override fun setFetchSize(rows: Int) {
        backingStatement.fetchDirection = rows
    }

    override fun getFetchSize(): Int {
        return backingStatement.fetchSize
    }

    override fun getResultSetConcurrency(): Int {
        return backingStatement.resultSetConcurrency
    }

    override fun getResultSetType(): Int {
        return backingStatement.resultSetType
    }

    override fun getConnection(): Connection {
        return backingStatement.connection
    }

    override fun getGeneratedKeys(): ResultSet {
        return backingStatement.generatedKeys
    }

    override fun getResultSetHoldability(): Int {
        return backingStatement.resultSetHoldability
    }

    override fun isClosed(): Boolean {
        return backingStatement.isClosed
    }

    override fun setPoolable(poolable: Boolean) {
        backingStatement.isPoolable = poolable
    }

    override fun isPoolable(): Boolean {
        return backingStatement.isPoolable
    }

    override fun closeOnCompletion() {
        backingStatement.closeOnCompletion()
    }

    override fun isCloseOnCompletion(): Boolean {
        return backingStatement.isCloseOnCompletion
    }
}
